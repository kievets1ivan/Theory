# typeof(), GetType(), is

## В чем собственно разница?

- typeof принимает имя типа (которое вы указываете во время компиляции).
- GetType выполняется на экземпляре типа,
- is возвращает true, если экземпляр находится в дереве наследования.

## Пример

```csharp 
    class Program
    {
        
        public static void Main(string[] args)
        {

            Dog spot = new Dog();
            PrintTypes(spot);

        }

        static void PrintTypes(Animal a)
        {
            Console.WriteLine((a.GetType() == typeof(Animal)));// false 
            Console.WriteLine(a is Animal);                   // true 
            Console.WriteLine(a.GetType() == typeof(Dog));  // true
        }

        class Animal { }
        class Dog : Animal { }

    }
```
## Окуратно с is:

```csharp 
if(o is Animal)
    ((Animal)o).Speak();
```
Но это делает CLR проверкой типа объекта до двух раз. Он проверит его один раз, чтобы удовлетворить оператор is, и если o действительно является Animal, мы заставляем его снова проверять подтверждение акта.

Более эффективно это сделать:

```csharp 
Animal a = o as Animal;
if(a != null)
    a.Speak();
```

Оператор as - это приведение, которое не генерирует исключение, если оно терпит неудачу, вместо этого возвращается null. Таким образом, CLR проверяет тип объекта только один раз, и после этого нам просто нужно выполнить нулевую проверку, что более эффективно.

Но будьте осторожны: многие люди попадают в ловушку с as. Поскольку это не вызывает исключений, некоторые люди считают его "безопасным" броском, и они используют его исключительно, избегая регулярных бросков. Это приводит к следующим ошибкам:

```csharp 
(o as Animal).Speak();
```

